# Software that performs

## Philosophy:

**Focus is deciding what you're not going to do**

- Focused, hard work is the real key to success
- Keep taking the next step towards the goal
- Most people work at a fraction of their potential

**Sometimes the elegant implementation is just a function**

- Not a method, not a class, not a framework
- The cost of an abstraction often outweighs its benefit
- Kill one today

## Performance and Optimization:

**The world could run on older hardware if optimization was a priority**

- More could run on outdated hardware than people imagine
- Rebuild interpreted microservices into monolithic native codebases
- Cheap compute kills the incentive, but the efficiency gains would be dramatic

**Worst case matters more than average case**

- Highly variable performance is unacceptable
- Favor consistent execution paths over "optimally" avoiding unnecessary work

**Restrict flexibility to do something better**

- Restricting flexibility almost always improves the result
- A feature's cost includes the obstacle to future expansion
- Pick features that don't fight each other

## Software Engineering:

**Software engineering is a social science**

- 90% of programming has no objectivity
- It's social interactions between programmers, or between yourself over time
- Most flaws come from not understanding all possible states

**Favor pure functions and minimize state mutation**

- The real enemy is unexpected dependency and mutation of state
- Pure functions solve this directly and completely
- If you mutate a lot of state, stay aware of the full horror of what you're doing

**Many smart decisions beat one brilliant one**

- One brilliant decision plus mediocre ones loses to smart decisions throughout
- Not sure which way? Do it both ways, see which works
- You can prematurely optimize maintainability and flexibility just like performance

## On Sharing:

**Programming is not a zero-sum game**

- Teaching a fellow programmer doesn't take it away from you
- Sharing code costs little and benefits many

**Low-level programming is good for the programmer's soul**

- Tight resource limits force extreme simplicity
- Modern software is abstracted more than necessary
- Moore's law means a competent programmer eventually replicates what a clever one did years earlier
